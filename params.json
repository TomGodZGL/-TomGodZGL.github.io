{"name":"Tomgodzgl.GitHub.io","tagline":"梁桑个人博客","body":"#梁桑个人博客#\r\n\r\n\r\n*此个人[博客](http://www.baidu.com)旨在技术交流，大家一起学习，欢迎大家指正*\r\n\r\n\r\n##大型网站优化##\r\n大型网站优化主要有以下两点：\r\n\r\n- 网站静态化\r\n- mysql优化\r\n\r\n###判断大型网站的基本概念###\r\n\r\n- pv值（page views）页面浏览量：\r\n是指，一个网站的所有页面，在一天内被访问的总的次数。达到千万级别以上，几百万以上\r\n- uv值（unique vistor）独立访客：是指一个网站，在一天内有多少个用户来访问我们的网站。一般几十万以上\r\n- 独立ip：是指一个网站，在一天内有多少个独立ip来访问我们的网站\r\n\r\n###大型网站带来的问题？###\r\n- 大的访问量（大并发）\r\n\r\n\t并发：是指在某个时间点，有多少个用户同时访问某个地址\r\n- 大的流量（带宽问题）\r\n\r\n\r\n- 海量的数据存储\r\n\r\n\t网站从小到大的数据的存储，比如数据表的容量达到GT级别，带来查询速度变慢，要从海量的数据表里面快速的查找到数据，是我们优化的重点。\r\n\r\n###大访问量问题###\r\n\r\n- 使用负载均衡以及分层架构服务器\r\n\r\n\t负载均衡说明：\r\n\r\n\t软件：lvs(linux virtual server)linux虚拟服务， nginx（web服务器，负载均衡）\r\n\r\n\t硬件：f5-bigip  :价格昂贵，立竿见影，效果非常好。一般是大的网游公司或大的门户网站使用\r\n\r\n\t负载均衡器的策略：\r\n\r\n\t- 轮询：载均衡把请求轮流转发给web服务器\r\n\t- 加权：配置性能高的，分配的权重就越大，处理的请求就越多\r\n\t- 最少连接：负载均衡把请求转发给最空闲的那台服务器\r\n\t- ip哈希：同一地址的客户端，负载均衡把请求始终给同一台服务器\r\n\r\n###大流量问题###\r\n- 在web 服务器端，配置压缩，减少数据传输的数据量\r\n\t\r\n\tApache上利用gzip压缩算法进行压缩的模块有两种：mod_gzip和mod_deflate. \r\n\r\n\t具体的步骤：\r\n\t\r\n\t1）打开apache的httpd.conf配置文件，开启压缩模块\r\n\t\r\n\t\tLoadModeule deflate_module modules/mod_deflate.so\t\r\n\r\n\t2）在虚拟主机里面，配置压缩的对象\r\n\r\n\t\t<ifmodule mod_deflate.c> \r\n\t\t\t#配置压缩的级别，压缩级别为6，可选1-9，推荐为6\r\n\t\t\tDeflateCompressionLevel 6\r\n\t\t\t#压缩文本文件      \r\n\t\t\tAddOutputFilterByType  DEFLATE text/plain   \r\n\t\t\t#压缩html文件\r\n\t\t\tAddOutputFilterByType  DEFLATE text/html   \r\n\t\t\t#压缩xml文件\r\n\t\t\tAddOutputFilterByType  DEFLATE text/xml    \r\n\t\t</ifmodule> \r\n\t\t注意：为什么要指定文件类型来压缩？\r\n\t\t压缩也是要耗费cpu资源的，图片/视频等文件，压缩效果不好，不要对其压缩。一般压缩的是文本格式的文件。\r\n\t\tDeflateCompressionLevel 指令来设置压缩级别。该指令的值可为1（压缩速度最快，最低的压缩质量）到9（最慢的压缩速度，压缩率最高）之间的整数，其默认值为6（压缩速度和压缩质量较为平衡的值）\r\n\r\n- 合并文件（样式文件，js文件，背景图片文件），减少http的请求\r\n\r\n- 把比较占用流量的资源（或不同的功能）单独部署服务器\r\n\r\n###大存储问题###\r\n- 使用缓存技术\r\n\r\n\t主要目的是：减少数据库的查询次数\r\n\t\r\n\t1）磁盘缓存（页面静态化）\r\n\r\n\t页面静态化，就是把一个动态（操作数据库）的页面，转换成一个.html页面。直接访问生成的.html页面。提高了访问速度，因为没有查询数据库\r\n\t\r\n\t2）内存缓存（redis/memcache）\r\n\r\n\t把数据缓存到服务器端的内存里面。下次访问时，直接从内存里面获取数据\r\n- 对mysql优化\r\n\r\n\t1）设计角度：存储引擎的选择，字段类型选择，范式\r\n\r\n\t2）利用mysql自身的特性：索引，查询缓存，分区分表，存储过程，sql语句优化配置，\r\n\r\n\t3）部署大负载架构体系：主从复制，读写分离。\r\n\r\n\t4）硬件升级\r\n\t\r\n\t**注**： 此mysql优化推荐参考 [骑着笨鸟慢慢飞](http://superve.leanote.com/) 个人技术博客\r\n\t \r\n###页面静态化详解###\r\n\r\n- 什么是页面静态化：\r\n\r\n\t就是把一个动态（操作数据库）的页面转换成一个.html页面。\r\n\t比如http://www.abc.com/goods.php?id=4;      \r\n\t可以变成http://www.abc.com/goods_id4.html\r\n \r\n\t页面静态化可以分为两种：真静态和伪静态。\r\n\t真静态：就是把一个动态的页面，实实在在的生成一个静态页面。\r\n\t伪静态：从形式上看是一个静态页面，实际上操作的还是动态页面。比如\r\n\thttp://www.abc.com/news-sport_id12.html\r\n\t实际上操作是：\r\n\thttp://www.abc.com/news.php?type=sport&id=12\r\n\r\n- 实现方式\r\n\r\n\t真静态的实现方式：使用ob缓存技术，ob缓存，缓存的内容是响应的主体数据。\r\n\r\n\t在请求一个php的过程中，我们实际上经过三个缓存，程序缓存，ob缓存，浏览器缓存。\r\n\r\n\t伪静态的实现方式：通过web服务器的重写机制，比如请求 index.html =》 index.php\r\n\r\n- 程序缓存\r\n\r\n\t该缓存是必须存在的，是无法关闭的。缓存的数据是响应的数据（响应的头和响应的主体数据）\r\n\r\n- ob缓存\r\n\r\n\tob就是 output_buffering:输出缓存，缓存的数据是响应的主体数据\r\n\t\r\n\t如果开辟了ob缓存，主体数据首先存储到ob缓存里面，头信息要存储到程序缓存（无论是否开启ob缓存），当代码执行完毕后，ob缓存里面的数据刷新（移动）到程序缓存，程序缓存再输出到浏览器缓存中，最后输出内容\r\n- 如何开启 ob缓存\r\n\r\n\t1）使用ob_start()函数，针对当前页面有效\r\n\r\n\t2）通过使用php.ini的配置文件来开启ob缓存，针对所有的页面都有效\r\n\r\n- ob相关的函数\r\n\r\n\tob_get_contents();//获取ob缓存里面的内容\r\n\r\n\tob_clean();//清空ob缓存里面的内容，不关闭ob缓存\r\n\t\r\n\tob_end_clean();//清空ob缓存里面的内容，并关闭ob缓存\r\n\r\n\tob_flush();//是把ob缓存里面的数据给刷新（移动）到程序缓存。不关闭ob缓存\r\n\r\n\tob_end_flush();是把ob缓存里面的数据给刷新（移动）到程序缓存。并关闭ob缓存\r\n\t\r\n\t获取ob缓存里面的数据内容：\r\n\r\n\t\t$content = ob_get_contents();响应主体的数据\r\n\t\tfile_put_contents(文件名称,’文件内容’);// 生成了一个静态页面\r\n\r\n- 真静态案例\r\n\t\r\n\t\t<?php \r\n\t\t\r\n\t\t    //接收参数\r\n\t\t    $goods_id = $_GET['goods_id'] + 0;\r\n\t\t    $lifetime = 24*3600*7;\r\n\t\t    //构造静态页面文件名\r\n\t\t    $filename = 'goods_' . $goods_id . '.html';\r\n\t\t\r\n\t\t    //判断文件是否存在且是否在生命周期中\r\n\t\t    if(file_exists($filename) && filemtime($filename) + $lifetime > time()) {\r\n\t\t        include $filename;\r\n\t\t        exit;\r\n\t\t    }\r\n\t\t    \r\n\t\t    //如果静态页面不存在，页面已经过期，则操作数据库\r\n\t\t    $link = mysql_connect('localhost:3306','root','root');\r\n\t\t    mysql_query('set names utf8');\r\n\t\t    mysql_query('use test');\r\n\t\t\r\n\t\t    $sql = \"select * from sh_goods where g_id = $goods_id\";\r\n\t\t    $res = mysql_query($sql);\r\n\t\t    $info = mysql_fetch_assoc($res);\r\n\t\t\r\n\t\t    ob_start();\r\n\t\t?>\r\n\t\t    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\r\n\t\t    <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"zh-CN\">\r\n\t\t    <head>\r\n\t\t    <title>商品详情页</title>\r\n\t\t    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n\t\t    <meta name=\"description\" content=\"\" />\r\n\t\t    <meta name=\"keywords\" content=\"\" />\r\n\t\t    <script type=\"text/javascript\">\r\n\t\t\r\n\t\t    </script>\r\n\t\t\r\n\t\t    <style type=\"text/css\">\r\n\t\t    </style>\r\n\t\t    </head>\r\n\t\t        <body>\r\n\t\t        <h1><?php echo $info['goods_name']?></h1>\r\n\t\t        <div><?php echo $info['goods_desc']?></div>\r\n\t\t        </body>\r\n\t\t    </html>\r\n\t\t\r\n\t\t<?php \r\n\t\t    $content = ob_get_contents();//获取ob缓存里面的数据内容\r\n\t\t    file_put_contents($filename,$content);\r\n\t\t\r\n\t\t?>\r\n###伪静态####\r\n\r\n实际开发项目中，我们的页面不适合使用真静态，但是你不仅希望页面安全性高，同时利于seo，可以考虑使用伪静态技术\r\n\r\n- 实现方式\r\n\r\n\t使用apache的重写模块，要开启重写模块（rewrite机制）。\r\n\t在重写模块中，要配置重写规则，在重写规则里面我们使用到正则表达式\r\n\r\n- 如何开启重写模块\r\n\r\n\t打开 httpd.conf文件，进行配置修改。添加rewrite_module模块\r\n\t\t\r\n\t\tLoadModule rewrite_module modules/mod_rewrite.so\r\n\r\n- 具体的重写规则的配置\r\n\r\n\t1）使用分布式文件配置，.htaccess文件\r\n\r\n\t2）在虚拟主机的配置文件中，要配置支持 .htaccess配置文件\r\n\r\n\t\tAllowOverride All\r\n\t\r\n\t3）在.htaccess文件中进行配置重写规则\r\n\t\t\r\n\t\tRewriteEngine  on \t开启重写引擎\r\n\t\tRewriteCond   \t\t重写条件\r\n\t\tRewriteRule\t\t\t重写规则\r\n\r\n\t4)RewriteCond重写条件语法\r\n\r\n\t\tRewriteCond 判断依据  条件表达式 [条件标志]\r\n\t\t\r\n\t5)案例说明\r\n\r\n\t\t<IfModule rewrite_module>\r\n\t\t\t#开启重写引擎\r\n\t\t\tRewriteEngine on\r\n\t\t\t#添加重写条件\r\n\t\t\tRewriteCond\t%{REQUEST_FILENAME} !-f\r\n\t\t\t#添加重写规则\r\n\t\t\tRewriteRule index.html\tindex.php\r\n\t\t</IfModule>\r\n\r\n\r\n- 防盗链\r\n\r\n\t1)为了防止外部使用网站图片资源可以添加水印\r\n\t\r\n\t2）利用重写机制，根据HTTP_PEFERER\r\n\r\n\t\t<IfModule rewrite_module>\r\n\t\t\tRewriteEngine on\r\n\t\t\t#判断URL的上一次访问是否本域名地址\r\n\t\t\tRewriteCond  %{HTTP_PEFERER} -www.demo.com[NC]\r\n\t\t\t#如果不会本网站访问，则禁止访问\r\n\t\t\tRewriteRule  \\.(jpg|png|jpeg|gif|bmp)\t-[F]\r\n\t\t</IfModule>\r\n\r\n\r\n##商品浏览记录代码实现##\r\n\r\n**获取商品历史浏览记录，利用thinkPHP框架开发，基于cookie实现**\r\n\r\n\tpublic function getHistory(){\r\n\t\t//判断cookie中时候有history数据存在\r\n\t\t$list = isset($_COOKIE['history']) ? unserialize($_COOKIE['history']) : array();\r\n\t\t$goods_id = (int)$_GET['id'];\r\n\t\t\r\n\t\t//判断用户是否浏览了商品\r\n\t\tif(!empty($goods_id)){\r\n\t\t\tif(!empty($list)){\t\t\r\n\t\t\t\t//获取商品ID\r\n\t\t\t\t$ids = array();\r\n\t\t\t\tforeach($list as $v){\r\n\t\t\t\t\t$ids[] = $v['goods_id'];\r\n\t\t\t\t}\r\n\t\t\t\t//判断商品是否已经存在,则删除\r\n\t\t\t\t$index = array_search($goods_id, $ids);\r\n\t\t\t\tif($index !== false){\r\n\t\t\t\t\t$history = $list[$index];\r\n\t\t\t\t\tunset($list[$index]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//根据商品ID获取商品详细信息\r\n\t\t\t\t\t$goodsinfo = M('Goods')->field('goods_name,shop_price,goods_thumb')->where(\"id = $goods_id\")->find();\r\n\t\t\t\t\t//构造新数组，并添加到浏览记录中\r\n\t\t\t\t\t$history = array(\r\n\t\t\t\t\t\t\t'goods_id'\t\t=>\t$goods_id,\r\n\t\t\t\t\t\t\t'goods_name'\t=>\t$goodsinfo['goods_name'],\r\n\t\t\t\t\t\t\t'shop_price'\t=>\t$goodsinfo['shop_price'],\r\n\t\t\t\t\t\t\t'goods_thumb'\t=>\t$goodsinfo['goods_thumb']\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\t//判断商品记录是否大于3条\r\n\t\t\t\tif(count($list) > 3){\r\n\t\t\t\t\tarray_pop($list);\r\n\t\t\t\t}\r\n\t\t\t\t//往数组的头部添加数据\r\n\t\t\t\tarray_unshift($list, $history);\t\t\t\t\t\t\t\r\n\t\t\t}else{\r\n\t\t\t\t//根据商品ID获取商品详细信息\r\n\t\t\t\t\r\n\t\t\t\t$goodsinfo = M('Goods')->field('goods_name,shop_price,goods_thumb')->where(\"id = $goods_id\")->find();\r\n\t\t\t\t\r\n\t\t\t\t//构造新数组，并添加到浏览记录中\r\n\t\t\t\t$history = array(\r\n\t\t\t\t\t\t'goods_id'\t\t=>\t$goods_id,\r\n\t\t\t\t\t\t'goods_name'\t=>\t$goodsinfo['goods_name'],\r\n\t\t\t\t\t\t'shop_price'\t=>\t$goodsinfo['shop_price'],\r\n\t\t\t\t\t\t'goods_thumb'\t=>\t$goodsinfo['goods_thumb']\r\n\t\t\t\t);\r\n\t\t\t\t//往数组的头部添加数据\r\n\t\t\t\tarray_unshift($list, $history);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//获取商品信息并将其放入cookie中，用于浏览历史使用\r\n\t\t\tsetcookie('history',serialize($list),time()+24*3600,'/');\t\t\t\r\n\t\t}\r\n\t\t//将数组返回\r\n\t\treturn $list;\t\r\n\t}\r\n\r\n\r\n##mysql优化##\r\n\r\n- 优化概述\r\n\r\n\t1. 设计角度：存储引擎的选择，字段类型大小的选择，使用notnull,范式支持\r\n\t2. 利用mysql自身特性：索引，查询缓存，存储过程，分区分表，sql语句优化\r\n\t3. 部署大负载架构体系：主从复制，读写分离\r\n\t4. 硬件升级\r\n\r\n- 分析需要优化的语句\r\n\r\n\t要分析的sql语句是执行速度比较慢的。查找执行速度比较慢的sql语句。找到后，具体分析\r\n\r\n\t1）慢查询日志\r\n\r\n\t是一种mysql提供的日志，记录所有执行时间超过某个时间界限的sql的语句。这个时间界限，我们可以指定。在mysql中默认没有开启慢查询，即使开启了，只会记录执行的sql语句超过10秒的语句。\r\n\r\n\t2）精确记录查询时间\r\n\r\n\t使用mysql提供的profile机制完成。 \r\n\r\n- 索引的介绍\r\n\r\n\t在myisam引擎里面，索引是单独的一个文件\r\n\r\n\t1）索引到底是什么？\r\n\r\n\t索引是一种，利用数据的某个特征（属性），快速定位该数据位置的技术 \r\n\t索引的作用：是用于快速定位实际数据位置的一种机制。\r\n\t索引在mysql中，是独立于数据的一种特殊的数据结构。\r\n\t就类似于，书里面的目录，办公大楼里面的导航牌\r\n\r\n\r\n\t2）索引的类型\r\n\r\n\t主键索引\r\n\t\r\n\t限制索引的关键字不能重复，并且不能为NULL。（不能为NULL的唯一索引）。一个表中只允许有一个主索引\r\n\r\n\t唯一索引\r\n\r\n\t限制索引的关键字不能重复的索引\r\n\r\n\t普通索引\r\n\r\n\t利用特定的关键字，标识数据记录的位置（磁盘上的位置，盘号，柱面，扇面，磁道）。 \t\r\n\r\n\t全文索引\r\n\r\n\t索引的关键字，不是某个字段的值，而是字段值中有意义的词来作为关键字建立索引。\r\n\r\n\t联合索引（复合索引）多个字段组合成一个索引\r\n\r\n\t如果一个索引（以上四种任何都可以），是依赖于多个字段创建的化，称之为复合索引。\r\n\r\n\r\n\t3）索引的建立\r\n\r\n\t\talter table tablename add primary key(id),\r\n\t\tadd unique key(name),\r\n\t\tadd index(age),\r\n\t\tadd fulltext index(intro),\r\n\t\tadd index(name,age);\r\n\r\n\t4)删除索引\r\n\r\n\t以alter语法的形式删除索引。\r\n\t删除主键索引，要注意什么问题？先删除自增的属性，然后再删除。\r\n\talter table 表名 drop primary key;\r\n\t删除其他索引，alter table 表名  drop  index 索引的名称\r\n\r\n\t5)查看索引\r\n\r\n\t\tshow indexes from table_name; \r\n\t\tshow index from table_name \r\n\t\tshow create table table_name \r\n\t\tshow keys from table_name \r\n\t\tdesc table_name\r\n\r\n- 索引的结构\r\n\r\n\t在mysql里面创建完成索引后，索引就是一个“排好序的快速查找结构”。\r\n\r\n\t1）MYism引擎的索引的数据结构\r\n\r\n\t索引的节点中存储的是数据的物理地址（磁道和扇区）\r\n\t在查找数据时，查找到索引后，根据索引节点中的物理地址，查找到具体的数据内容\r\n\r\n\t2）innodb的索引的数据结构\r\n\r\n\tinnodb的主键索引文件上 直接存放该行数据,称为聚簇索引\r\n\t\r\n\tinnodB的非主键索引，非主索引指向对主键的引用\r\n\r\n\t注意: innodb来说\r\n\r\n\t\r\n\t- 主键索引 既存储索引值,又在叶子中存储行的数据\r\n\r\n\t\r\n\t- 如果没有主键, 则会Unique key做主键 \r\n\r\n\t\r\n\t- 如果没有unique,则系统生成一个内部的rowid做主键. \r\n\r\n\t\r\n\t- 像innodb中,主键的索引结构中,既存储了主键值,又存储了行数据,这种结构称为”聚簇索引” \r\n\r\n- 创建索引的注意事项\r\n\r\n\t1）较频繁的作为查询条件字段应该创建索引\r\n\r\n\tselect * from emp where empno = 1\r\n\r\n\t2）唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件\r\n\r\n\tselect * from emp where sex = '男‘   is_new=0   is_best is_hot\r\n\r\n\t3）更新非常频繁的字段不适合创建索引\r\n\r\n\tselect * from emp where logincount = 1\r\n\r\n\t4）不会出现在WHERE子句中字段不该创建索\r\n\r\n##翻页优化和延迟缓存##\r\n\r\n\r\n\t- 从业务上去解决\r\n\r\n\t- 不用offset用条件查询\r\n\r\n##mysql的基础##\r\n\r\n- select语句\r\n\r\n\tselect [select 选项]（all 与 distinct（去重）） */字段列表 from 数据源 [where字句] [group by字句][having字句][order by 字句][limit字句]\r\n\r\n- where字句\r\n\r\n\t对数据进行判断： 将字段中的数据取出来进行比较匹配\r\n\r\n\tWhere条件的原理: where是每一次从磁盘读取一条记录后,都判断其条件: 条件符合放到最终的结果集合中,否则就放弃.\r\n\r\n\tWhere是从磁盘获取数据后直接判断: where之后的所有操作都是在内存中处理(不是磁盘)\r\n\r\n- group by 字句\r\n\r\n\tselect * from student where 1 group by c_id \r\n\t\r\n\t磁盘数据全部符合条件，将所有记录加载到结果集\r\n\t分组group by c_id系统发现没有任何统计操作，直接返回结果，只会返回每组的第一条记录\r\n\r\n\t回溯统计：当分组下去之后,最终需要统计分组的结果: 每一层分组都需要根据分组信息进行一次额外的统计\r\n\tGroup by 字段列表 with rollup\r\n\r\n\r\n##memcache高性能分布式内存对象缓存系统##\r\n\r\n###通过telnet访问memcache缓存系统###\r\n\t\r\n- 语法：add key 是否压缩 缓存周期 数据大小\r\n\r\n\tadd name 0 3600 5\r\n\t\r\n\tnihao \r\n\r\n- 语法：get key \r\n\r\n- 修改数据：replace key 0|1 缓存时间 \t数据大小\r\n\r\n- 设置数据：set key 0|1\t缓存时间\t数据大小\r\n\r\n- 删除数据：delete key \r\n\r\n- 执行加法操作：incr key 值\r\n\r\n- 执行减法操作：decr key 值\r\n\r\n- 清空内存：flush_all\r\n\r\n- 查看状态：stats\r\n\r\n###通过php操作memcache缓存系统###\r\n\r\n- 安装php支持memcache的扩展\r\n\r\n\t1）下载与php版本一致的memcache安装包\r\n\t\r\n\t2）把对应的扩展文件，拷贝到php的安装目录ext文件夹里面\r\n\r\n\t3）打开php.ini文件，引入该扩展\r\n\r\n\t\textendsion=php_memcache.dll\r\n\t4)重启web服务器（Apache）,测试是否生效\r\n\r\n\t\t<?php \r\n\t\t\tphpinfo();\r\n\r\n- memcached对php数据类型的支持\r\n\r\n\t1)标量数据类型存储\r\n\t\r\n\t说明：php数据类型的标量数据在memcache里面存储是以字符串的形式来存储的。实际上memcache本身没有数据类型之分，都是以字符串的形式来存储的\r\n\r\n\t2)非标量数据类型的存储\r\n\r\n\t注意：数组与对象是被序列化后以字符串的形式来存储的。序列化与反序列化是memcache的扩展内置的，我们无需干预。资源类型是无法存储到memcache 里面，因为资源类型被转换成整型0来存储的\r\n\r\n- memcache的使用的基本案例\r\n\r\n\t案例描述：根据热点新闻列表页的URL，点击跳转到热点新闻详情页\r\n\r\n\t数据表结构\r\n\t\t\r\n\t\tcreate table news(\r\n\t\t\tid int primary key auto_increment,\r\n\t\t\ttitle varchar(64) not null,\r\n\t\t\tcontent text not null\r\n\t\t)engine myisam default charset utf8;\t\r\n\r\n\t热点新闻的列表页面：list.php\r\n\r\n\t\t<?php\r\n\t\t   $conn = mysql_connect('localhost','root','root');\r\n\t\t    mysql_query('use php');\r\n\t\t    mysql_query('set names utf8');\r\n\t\t    $sql=\"select id,word from cetsix limit 100,10\";\r\n\t\t    $res = mysql_query($sql);\r\n\t\t    $info=array();\r\n\t\t    while($row=mysql_fetch_assoc($res)){\r\n\t\t        $info[]=$row;\r\n\t\t    }\r\n\t\t\r\n\t\t?>\r\n\t\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\r\n\t\t<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"zh-CN\">\r\n\t\t\t<head>\r\n\t\t\t<title>新建网页</title>\r\n\t\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n\t\t\t<meta name=\"description\" content=\"\" />\r\n\t\t\t<meta name=\"keywords\" content=\"\" />\r\n\t\t\t</head>\r\n\t\t\t<body>\r\n\t\t\t<table  width=\"600\" border=\"1\">\r\n\t\t        <tr>\r\n\t\t            <td>编号</td>\r\n\t\t            <td>标题</td>\r\n\t\t            <td>操作</td>\r\n\t\t        </tr>\r\n\t\t        <?php foreach($info as $v){?>\r\n\t\t        <tr>\r\n\t\t            <td><?php echo $v['id']?></td>\r\n\t\t            <td><a href=\"newsinfo.php?id=<?php echo $v['id']?>\"><?php echo $v['word']?></a></td>\r\n\t\t            <td><a href=\"#\">修改</a>|<a href=\"#\">删除</a></td>\r\n\t\t        </tr>\r\n\t\t        <?php }?>\r\n\t\t\t</table>\r\n\t\t\t</body>\r\n\t\t</html>\r\n\r\n\t热点新闻的详情页面：newsinfo.php\r\n\r\n\t\t<?php\r\n\t\t    //实例化memcache\r\n\t\t    $mem = new Memcache();\r\n\t\t    //连接memcache\r\n\t\t    $mem->connect('localhost',11211);\r\n\t\t\r\n\t\t    //接收参数新闻列表传递过来新闻ID\r\n\t\t    $id = $_GET['id'] + 0;\r\n\t\t    $key = 'newsid_' . $id ; \r\n\t\t    \r\n\t\t    //从memcache里面取出来，\r\n\t\t    $info = $mem->get($key);\r\n\t\t    \r\n\t\t   if(!$info){\r\n\t\t         //连接数据库，把新闻显示到列表页面\r\n\t\t        $link = mysql_connect('localhost','root','root');\r\n\t\t        mysql_query('set names utf8');\r\n\t\t        mysql_select_db('test');\r\n\t\t        //组织sql\r\n\t\t        $sql = \"select id,title from news where id = $id\";\r\n\t\t        $res = mysql_query($sql);\r\n\t\t        $info = mysql_fetch_assoc($res);\r\n\t\t        //将数据缓存到memcache中\r\n\t\t        $mem->add($key,$info,0,3600);\r\n\t\t   }\r\n\t\t?>\r\n\t\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\r\n\t\t<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"zh-CN\">\r\n\t\t\t<head>\r\n\t\t\t<title>新闻详情页</title>\r\n\t\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n\t\t</head>\r\n\t\t\t    <body>\r\n\t\t\t    <h1><?php echo $info['title']?></h1>\r\n\t\t\t    <hr/>\r\n\t\t\t    <div><?php echo $info['content']?></div>\r\n\t\t\t    </body>\r\n\t\t</html>\r\n\r\n\r\n- 分布式服务器的配置\r\n\r\n\t组成使用：（1）至少两台memcache服务器  （2）使用memcache分布式算法的问题，该算法是内置的，我们自己无需干预。\r\n\r\n\t案例说明：添加数据\r\n\r\n\t\t<?php\r\n\r\n\t\t    //实例化memcache对象\r\n\t\t    $mem = new Memcache();\r\n\t\t    $mem->addServer('192.168.1.101',11211);\r\n\t\t    $mem->addServer('192.168.1.103',11211);\r\n\t\t    $mem->add('name','tom',0,3600);\r\n\t\t    $mem->add('age',18,0,3600);\r\n\t\t    $mem->add('sex','男',0,3600);\r\n\t\t    $mem->add('hobby',array('besketball','football','tennis'),0,3600);\r\n\t\t    $work = new stdClass();\r\n\t\t    $work->play = 'shangban';\r\n\t\t    $work->doing = 'shangwang';\r\n\t\t    $mem->add('work',$work,0,3600);\r\n\t\t    \r\n\t\t    echo '数据添加成功';\r\n\r\n\t查询数据：\r\n\t\t\r\n\t\t$mem = new Memcache();\r\n\t    $mem->addServer('192.168.1.101',11211);\r\n\t    $mem->addServer('192.168.1.103',11211);\r\n\t\techo $mem->get('name');\r\n\t    echo '<hr/>';\r\n\t    echo $mem->get('age');\r\n\t    echo '<hr/>';\r\n\t    echo $mem->get('sex');\r\n\t    echo '<hr/>';\r\n\t    var_dump($mem->get('hobby'));\r\n\t    echo '<hr/>';\r\n\t    var_dump($mem->get('work'));\r\n\r\n- 把session数据存储到memcache里面\r\n\r\n\t基本的配置:\r\n\t\r\n\t主要通过修改php.ini的配置文件，即可:\r\n\t\r\n\t1. 保证memcache扩展开启，memcachd运行\r\n\t2. 设置php.ini中session.save_handler=memcache\r\n\t3. 置php.ini中session.save_path=‘tcp://localhost:11211’（可以是用逗号分隔的列表）\r\n\t4. 也可以通过php函数 ini_set() 函数在页面设置ini_set(\"session.save_handler\",\"memcache\");ini_set(\"session.save_path\",\"tcp://localhost:11211\")\r\n\t5. 如果session数据入mem,则是以 session_id为key值进行添加\r\n\r\n\t使用方式:和之前的使用session的方式是一样的\r\n\r\n\t设置:\r\n\t\r\n\t\t<?php\r\n\t\t\tsession_start();\r\n\t\t\t$_SESSION['name'] = 'tom';\r\n\t\t\techo 'ok';\r\n\r\n\t获取数据：\r\n\t\t\t\r\n\t\t<?php \r\n\t\t\t//开启session机制\r\n\t\t\tsession_start();\r\n\t\t\techo $_SESSION['name'];\r\n\r\n\t注意：当session数据保存到memcached中，他的生命周期还是以seesion的生命周期来管理的。 \r\n\r\n- 安全机制\r\n\r\n\t由于memcache没有任何的安全机制，如何控制安全，只有服务器系统层面来设置安全性，比如防火墙的配置，selinux等等。通常memcache服务器，是放到私有网络（公司的内网）里面，并不对外公开。\r\n\r\n\tmemcache启动时的命令：-l 监听的IP地址, 默认是本机\r\n\r\n- 其他问题\r\n\r\n\t\r\n\t1. 惰性删除\r\n\r\n\t\tmemcached内部不会监视记录是否过期，而是在get时查看记录\r\n\t\t的时间戳，检查记录是否过期。这种技术被称为lazy（惰性）expiration。因此，memcached不会在过期监视上耗费CPU时间。\r\n\r\n\t\t比如设置了一条数据：add name  0   3600  5    \r\n\r\n\t\t该条数据失效时间是3600秒，但是过了3600秒后，该条数据并不会自动删除，要等执行get查询的时候，查看该条记录的时间戳，如果过期则删除\r\n\t2. 最近最少使用原则\r\n\r\n\t\tmemcached会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不足的情况，此时就要使用名为 Least Recently Used（LRU）机制来分配空间。顾名思义，这是删除“最近最少使用”的记录的机制。因此，当memcached的内存空间不足时（无法从slab class 获取到新的空间时），就从最近未被使用的记录中搜索，并将其空间分配给新的记录。从缓存的实用角度来看，该模型十分理想。\r\n\r\n\t\t比如：设置的memcache的缓存空间为64MB(默认是64Mb)，当空间满了，如果再存储数据，能否被存储？答：可以的，会自动踢除最不活跃的数据。\r\n\t3. 哪些数据比较适合于存储memcahe\r\n\r\n\t\t1）数据安全性比较差的（丢失无所谓的）\r\n\r\n\t\t2）数据查询比较频繁的，可以把数据给缓存到memcache里面\r\n\r\n\t\t3）数据量不要太大，要少于1M\r\n\r\n\t\t4）更新比较频繁的数据，比如用户的在线状态\r\n\r\n\t4. Memcached作为高速运行的分布式缓存服务器，具有以下的特点：\r\n\r\n\t\t1)协议简单\r\n\r\n\t\t2）基于libevent（基于事件触发的高性能网络库）事件处理\r\n\t\r\n\t\t3)内置内存存储方式\r\n\r\n\t\t4）memcached不互相通信的分布式\r\n\r\n\r\n\t\t\r\n\t5. 启动时，一些命令\r\n\r\n\t\t\t-p 监听的端口 \r\n\t\t\t-l 连接的IP地址, 默认是本机  \r\n\t\t\t-d start 启动memcached服务 \r\n\t\t\t-d restart 重起memcached服务 \r\n\t\t\t-d stop|shutdown 关闭正在运行的memcached服务 \r\n\t\t\t-d install 安装memcached服务 \r\n\t\t\t-d uninstall 卸载memcached服务 \r\n\t\t\t-u 以的身份运行 (仅在以root运行的时候有效) \r\n\t\t\t-m 最大内存使用，单位MB。默认64MB \r\n\t\t\t-M 内存耗尽时返回错误，而不是删除项 \r\n\t\t\t-c 最大同时连接数，默认是1024 \r\n\t\t\t-f 块大小增长因子，默认是1.25 \r\n\t\t\t-n 最小分配空间，key+value+flags默认是48 \r\n\t\t\t-h 显示帮助\r\n\t\t\t-v  输出警告和错误信息。\r\n\t\t\t-vv 打印客户端的请求和返回信息\r\n\t\t\t-i 打印memcached和libevent的版权信息。\r\n\r\nmemcached用slab allocator缓解内存碎片化\r\n\r\nslab allocator 原理：预告把内存划分成数个slab allocator仓库。各仓库，切分成不同尺寸的小块（chunk），需要存内容时，判断内容的大小，为其选取合理个仓库\r\n\r\nmemcached根据收到的数据的大小，选择最合适数据的大小的chunk组（slab class）,memcached中保存着slab class 内空闲chunk的列表，根据该列表选择空的chunk，然后将数据缓存于其中\r\n\r\n固定大小chunk带来的内存浪费\r\n\r\ngrow factor调优\r\n\r\nmemcached的过期数据惰性删除\r\n\r\n中继mysql主从复制延迟数据\r\n\r\n\t可以添加memcached作为中间过渡\r\n\r\n\r\n取模法\r\n\r\n比如本来memcached服务器有八台，现在down了一台，现在剩下一台，\r\n那么原来的7-56之间的数据都会miss，\r\n\r\n\r\n一致性哈希\r\n\r\n分布式一致性哈希\r\n\r\n命中率的提升的方案\r\n\r\n其一,提高服务获取的内存总量\r\n其二,提高空间利用率,这实际上也是另一种方式的增加内存总量\r\n其三,应用一级别上再来一次LRU\r\n其四,对于整体命中率,可以采取有效的冗余策略,减少分布式服务时某个server发生服务抖动的情况\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#mongodb#\r\n\r\n##基本简介##\r\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的，语法有点类似javascript面向对象的查询语言，它是一个面向集合的，模式自由的文档型数据库。\r\n它的特点是高性能、易部署、易使用，存储数据非常方便。\r\n\r\n1）主要目标：高的性能，扩展强（分布式存储）\r\n\r\n2）面向文档的数据库\r\n\r\n3）以bson格式存储数据\r\n\r\n4）javascript作为操作语言\r\n\r\n5）支持多种语言：php python java c++等\r\n\r\n6）支持GridFs(大文件存储)\r\n\r\n\r\n##应用范围和限制##\r\n不支持连表查询，不支持sql语句，不支持事务存储过程等，所以不适合存储数据间关系比较复杂的数据，一般主要是当做一个数据仓库来使用。\r\n适用于：日志系统，股票数据，等。\r\n\r\n\r\n##基本概念##\r\n- 文档\r\n\r\n\t文档是mongodb中数据的基本单位，类似于关系型数据库的性\r\n\r\n\t多个键值对有序地放置在一起便是文档。\r\n\t{键1：值1,键2：值2，键3：值3……………}\r\n\r\n\t{ “username”:”Tom”, “age”:10 }\r\n\r\n\t{ \"username\":\"Tom\" , \"age\" : \"10\" } \r\n\r\n\t{“Username”:”Tom”,”age”:10}\r\n\r\n\t注意：\r\n\r\n\t1.以上是3个不同的文档，MongoDB区分大小写的数据类型，第一个age字段是数字类型，第二个age是字符串类型。\r\n\r\n\t2. 每一个文档尺寸不能超过16M  \r\n\r\n安装\r\n\r\nmongodb   --install  --logpath 指定日志文件（全路径） --dbpath  指定数据库文件存储目录\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}